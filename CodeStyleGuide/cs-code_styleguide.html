<!--
title: C# Code Styleguide
description: Styleguide on how we want C# Code to be developed for Pamaxie
published: true
date: 2021-09-14T12:09:48.170Z
tags: 
editor: ckeditor
dateCreated: 2021-09-13T12:42:44.983Z
-->

<h1>C# with Pamaxie</h1>
<p>This tyle guide is for C# code that was developed by Pamaxies team and is used in all its publically facing or internal projects. It makes choices to make the style of coding uniform across applications and languages such as C or C++. This is build off of <a href="https://google.github.io/styleguide">Googles Code Style Guide</a>.</p>
<h1>Formatting Guidelines</h1>
<h6>Naming Rules</h6>
<p>Naming rules follow <a href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines">Microsoft's C# naming guidelines</a>. Where Microsoft's naming guidelines are unspecified (e. g. private and local variables), the rules can be seen below.</p>
<h6>Rules Summary:</h6>
<p><strong>Code:</strong></p>
<ul>
  <li>Names of classes, methods, enumerations, public fields, public properties, namespaces: <code>PascalCase</code></li>
  <li>Names of local variables, parameters: <code>camelCase</code></li>
  <li>Names of private, protected, internal and protected internal fields and properties: <code>_camelCase</code></li>
  <li>Naming convention is unaffected by modifiers such as const, static, readonly, overwrite, etc…</li>
  <li>For casing a “word” is anything written without internal spaces, including acronyms. This would mean <code>RPC</code> would become <code>Rpc</code></li>
  <li>Enums should be seperated out of classes whenever it isn't only required for that class.</li>
  <li>Names of interfaces start with an capital I: <code>IInterface</code></li>
  <li>Names of enums should be in singular.</li>
</ul>
<p>Files:</p>
<ul>
  <li>Filenames and directory names are PascalCase: <code>MyFile.cs</code></li>
  <li>Where possible the file name should be the same as the name of the main class in the file: <code>MyClass.cs</code></li>
  <li>In general, prefer one class or enum per file. This means enums and files should be seperated.</li>
  <li>Enums should be their own file where it makes sense.</li>
</ul>
<h6>Organization</h6>
<ul>
  <li>Modifiers occur in the following order: <code>public</code> <code>protected</code> <code>internal</code> <code>private</code> <code>new</code> <code>abstract</code> <code>viritual</code> <code>override</code> <code>sealed</code> <code>static</code> <code>readonly</code> <code>extern</code> <code>unsafe</code> <code>volatile</code> <code>async</code></li>
  <li>Namespace <code>using</code> declarations go at the top, <strong>BEFORE</strong> any namespaces. <code>using</code> import order is alphabetical, apart from <code>System</code> or <code>Microsoft</code> imports which <strong>always</strong> go first.</li>
  <li>Class member ordering:<ul>
      <li>Group class members in the following order:<ul>
          <li>Nested classes, enums, delegates and events</li>
          <li>Static, const and readonly fields.</li>
          <li>Fields and properties.</li>
          <li>Constructors and finalizers.</li>
          <li>Methods</li>
        </ul>
      </li>
      <li>Within each group, elements should be in the following order:<ul>
          <li>Public</li>
          <li>Internal</li>
          <li>Protected internal</li>
          <li>Protected</li>
          <li>Private</li>
        </ul>
      </li>
      <li>Where possible, group interface implementations together.</li>
    </ul>
  </li>
</ul>
<h6>Whitespace rules</h6>
<p>Inspired from Google's Java and C# style.</p>
<ul>
  <li>A maximum of ONE statement per line.</li>
  <li>A maximum of ONE assignement per statement.</li>
  <li>Indentation of one tab.</li>
  <li>Column limit: 100.</li>
  <li>Line break before opening brace</li>
  <li>Line break between functions and <code>static</code>, <code>public</code> and <code>private</code> properties.</li>
  <li>Two linebreaks between <code>public</code>, <code>private</code> and <code>static</code> methods</li>
  <li>Line break between closing brace and <code>else</code></li>
  <li>NewLines <strong>before </strong>and <strong>after</strong> <code>if</code> / <code>foreach</code> / <code>for</code> blocks</li>
  <li>Braces used even when optional</li>
  <li>Properties with backing fields should <strong>ONLY</strong> be used when needed.</li>
  <li>No space after an opening paranthesis and before a closing Paranethesis.</li>
  <li>No space between an unary operater and its operand. One space bween the operator and each operand of all other operators.</li>
  <li>Line warapping:<ul>
      <li>In general, line continuations are indented 4 spaces.</li>
      <li>Line breaks with braces (e.g. list inits, lamabads, object inits, etc) do NOT count as continuations.</li>
      <li>For function definitions and calls, if the argument do not all fit in one line they should be broken onto multiple lines,&nbsp;<br>with each subsequent line aligned with the first argument. If there is not enough room for this, arguments may instead be placed<br>on subsequent lines with a four space indent.</li>
    </ul>
  </li>
</ul>
<h5>Example:</h5>
<pre><code class="language-cs">using System; //'using' goes at the top, outside of the namespace.
using Microsoft.Extensions.Primities; //Sort usings from: System, Microsoft and then Alphabetical
using Newtonsoft.Json;


namespace MyNamespace //Namespaces are PascalCase
{ //Indantation before the bracket
    public interface IMyInterface //Interfaces start with an 'I'
    {
        public int Calculate(float value, float exp);
    }

    public enum MyEnum //Enumerations are PascalCase
    {
        Yes, //Enumerators are PascalCase
        No,
    }

    public class MyClass //Classes are PascalCase.
    {
        private const int _barSize = 100; //Backing fields are at the top. Const does not affect naming conventions
        private bool _noCounting = false; //Backing Fields are _camelCase. Field initializers are encouraged.
        private int[] _someTable = //Container initializers use a tab space indent.
        {
        	2, 3, 4
        }


        public int Foo = 0;//Public member variables are PascalCase, two newlines between private and public properties.

        public bool NoCounting //public properties with backing fields, should only be used where needed
        {
            get =&gt; return _noCounting;
            set =&gt; SetValue(ref _noCounting, value);
        }

        public MyClass() //Indent before bracket during method call, constructor comes after fields and properties.
        {
            _results = new Results //Object initializers use a tab space indent.
            {
                NumNegativeResults = 1,
                NumPositiveResults = 1,
            }
        }
        
        private void DoNothing(){} //Empty blocks may be concise.

        private void AVeryLongFunctionNameThatCausesLineWrappingProblems(int longArgumentName, //If possible, wrap arguments by aligning newlines with the first argument.
            																										 int p1, int p2)
        {
        }

        private void AnotherLongFunctionNameThatCausesLineWrappingProblems( // If aligning argument lines with the first argument doesn't fit, or is difficult to
            int longArgumentName, int longArgumentName2, int longArgumentName3)  // read, wrap all arguments on new lines with a 4 space indent
        {
        }

        private void CallingLongFunctionName()
        {
            int veryLongArgumentName = 1234;
            int shortArg = 1;
            
            AnotherLongFunctionNameThatCausesLineWrappingProblems(shortArg, shortArg, // If possible, wrap arguments by aligning newlines with the first argument.
                																									veryLongArgumentName);
            
            
            AnotherLongFunctionNameThatCausesLineWrappingProblems( // If aligning argument lines with the first argument doesn't fit, or is difficult to
                veryLongArgumentName, veryLongArgumentName, veryLongArgumentName); // read, wrap all arguments on new lines with a 4 space indent.
        }
        
        
        public int CalculateValue(int mulNumber) // two newlines between public and private methods.
        {
            var resultValue = Foo * mulNumber;
            NumTimesCalled++;
            Foo += _bar;

            if (!NoCounting) //Newline before if statemnt and opening brace
            {
            	
                if (resultValue &lt; 0) //Newline before if blocks
                { //Braces used even when optional
                    _results.NumNegativeResults++;
                    
                } //New between brace and else
                else if (resultValue &gt; 0)
                {
                    _results.NumPositiveResults++
                }
            }

            return resultValue; //Newline after if blocks
        }

        public void ExpressionBodies()
        {
            Func&lt;int, int&gt; increment = x =&gt; x + 1; //For simple lambdas, fit on one line if possible, no brackets or braces required.
            
            Func&lt;int, int, long&gt; difference1 = (x, y) =&gt; //Closing brace aligns with first character on line that includes the opening brace.
            {
                long diff = (long)x - y;
                return diff &gt;= 0 ? diff : -diff;
            };
            
            Func&lt;int, int, long&gt; difference2 = // If defining after a continuation line break, indent the whole body.
                (x, y) =&gt;
                {
                    long diff = (long)x - y;
                    return diff &gt;= 0 ? diff : -diff;
                };
                
            CallWithDelegate( // Inline lambda arguments also follow these rules. Prefer a leading newline before groups of arguments if they include lambdas.
                (x, y) =&gt;
                {
                    long diff = (long)x - y;
                    return diff &gt;= 0 ? diff : -diff;
                });
        }
    }
}</code></pre>
<h1>C# coding guidelines</h1>
<h6>Constants</h6>
<ul>
  <li>Variables and fields that can be made <code>const</code> should ALWAYS be made <code>const</code>.</li>
  <li>If <code>const</code> isn't possible, <code>readonly</code> static can be a suitable alternative.</li>
  <li>if <code>readonly</code> isn't possible, consider using a <code>static</code> value.</li>
</ul>
<h6>IEnumerable vs IList vs IReadOnlyList</h6>
<ul>
  <li>For inputs use the most restrictive collection type possible, for example <code>IReadOnlyCollection</code> / <code>IReadOnlyList</code> / <code>IEnumerable</code> as imputs to methods when the inputs should be made immutable.</li>
  <li>For outsputs, if passing ownership of the returned container to the owner, prefer <code>IEnumerable</code> over <code>IList</code>. If not transferning ownership, prefer the most restrictive option.</li>
</ul>
<h6>Generators vs containers</h6>
<p>Use your best judgement depending on scenario. Please keep in mind that while generator code is often less readable than filling in a container, it can be more performant, except if it is directly turned into a container via <code>.ToList()</code>. Also using generator code that is called multiple times will be considerably slower than iterating over a container multiple times.</p>
<h6>Propety Styles</h6>
<ul>
  <li>For single line, readonly properties, prefer expression body properties (=&gt;) when possible.</li>
  <li>For everything else use the older <code>{ get; set; }</code> syntax.</li>
</ul>
<h6>Expression body syntax</h6>
<p>For example:</p>
<pre><code class="language-cs">int SomeProperty =&gt; _someProperty;</code></pre>
<p>&nbsp;</p>
<ul>
  <li>Use expression syntax in lambadas and properties where possible.</li>
  <li>Use on method definitions.</li>
  <li>As with methods and other scoped blocks of code, align the closing with the first character of the line that includes the opening brace.<br>Se sample code for examples</li>
</ul>
<h6>Structs and classes</h6>
<ul>
  <li>Structs are different from classes:<ul>
      <li>Structs are ALWAYS passed and returned by value</li>
      <li>Assigning a value to a member of a returned struct doesn't modify the original - e.g. <code>transform.position.x = 10</code> doesn't set the transform's <code>position.x</code> to 10;&nbsp;<br><code>position</code> here is a property that returns a <code>Vector3</code> by value, so this just sets the x parameter of a copy of the original.</li>
    </ul>
  </li>
  <li>Almost alyways use a class when possible</li>
  <li>Consider struct when the type can be treated like any other value types. For example: if instances of the type are small and communly short lived or commonly embedded in other objects. (Good example are: Vector3, Bounds, Quaternion)</li>
  <li>Note that this guide may vary on this, for example, performance issues may force us to use structs.</li>
</ul>
<h6>Lambdas vs named methods</h6>
<ul>
  <li>If a lambda is non-trivial (e.g. more than a couple of statements, exclude declarations), or is reused in multiple places, it should probably be a named method.</li>
  <li>Avoid using Lambdas for complex sorting / searches, <code>for</code> / <code>foreach</code> loops should be applied where debugging the software gets too complex</li>
</ul>
<h6>Field initializers</h6>
<ul>
  <li>Field initializers are generally encouraged.</li>
</ul>
<h6>Extension methods</h6>
<ul>
  <li>Only use extension methods when the source of the original class is not available, or else when changing the source could would not be feasable.</li>
  <li>Only use an extension method if the functionality being added is a ‘core’ general feature that would be approperiate to add to the source of the original class.</li>
  <li>Only put extension methods into core libraries / classes that are available everywhere - extensions that are only available in some code (projects), which use things like <code>strings</code> will become a readability issue.</li>
  <li>Be aware that using extension methods ALWAYS obfuscates the code, so err on the side of not adding them.</li>
</ul>
<h6>ref amd pit</h6>
<ul>
  <li>Use <code>out</code> for returns that are not also inputs.</li>
  <li>Place <code>out</code> parameters after ALL other parameters in the method definition.</li>
  <li><code>ref</code> should only be used, when mutating an input is nessecary.</li>
  <li>Do not use <code>ref</code> as an optimization for passing structs.</li>
  <li>Do not use <code>ref</code> to pass a modifiable container into a method. <code>ref</code> is only required when the supplied container needs to be replaced with an entirely different container instance.</li>
</ul>
<h6>LINQ</h6>
<ul>
  <li>In general, prefer single line LINQ calls and imperative code, rather than long chains of LINQ. Mixing imperative code and heavily chained LINQ is often harder to read.</li>
  <li>Do not use SQL-Style LINQ keywords - e.g. use <code>myList.Where(x)</code> not <code>myList where x</code>.</li>
  <li>Avoid <code>Container.Foreach(…)</code> for anything that is longer than a single statement (prefer for loops).</li>
  <li>Wrap long LINQ statements with a new line after each statement. Indent the newline to start on the same height as other LINQ statements when possible.</li>
</ul>
<p>Example:</p>
<pre><code class="language-cs">
var types = myList.Where(x =&gt; x.Name == SearchedForName) 	//Wrap long LINQ statements with a new line after each statement.
	  			  .Select(x =&gt; x.Types).ToArray(); 			//Indent newline to start on the same height as other statements when possible.

for(int i = 0; i &gt; types.Lenth; i++) // avoid foreach for anything longer than single statement
{
	
	if(type == searchedForType) //newline before if statement
	{
		return;
	}
}</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
