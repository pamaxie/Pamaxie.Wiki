<!--
title: C# Code Styleguide
description: Styleguide on how we want C# Code to be developed for Pamaxie
published: true
date: 2021-09-14T11:18:31.771Z
tags: 
editor: ckeditor
dateCreated: 2021-09-13T12:42:44.983Z
-->

<h1>C# with Pamaxie</h1>
<p>This tyle guide is for C# code that was developed by Pamaxies team and is used in all its publically facing or internal projects. It makes choices to make the style of coding uniform across applications and languages such as C or C++. This is build off of <a href="https://google.github.io/styleguide">Googles Code Style Guide</a>.</p>
<h1>Formatting Guidelines</h1>
<h6>Naming Rules</h6>
<p>Naming rules follow <a href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines">Microsoft's C# naming guidelines</a>. Where Microsoft's naming guidelines are unspecified (e. g. private and local variables), the rules can be seen below.</p>
<h6>Rules Summary:</h6>
<p><strong>Code:</strong></p>
<ul>
  <li>Names of classes, methods, enumerations, public fields, public properties, namespaces: <code>PascalCase</code></li>
  <li>Names of local variables, parameters: <code>camelCase</code></li>
  <li>Names of private, protected, internal and protected internal fields and properties: <code>_camelCase</code></li>
  <li>Naming convention is unaffected by modifiers such as const, static, readonly, overwrite, etc…</li>
  <li>For casing a “word” is anything written without internal spaces, including acronyms. This would mean <code>RPC</code> would become <code>Rpc</code></li>
  <li>Enums should be seperated out of classes whenever it isn't only required for that class.</li>
  <li>Names of interfaces start with an capital I: <code>IInterface</code></li>
  <li>Names of enums should be in singular.</li>
</ul>
<p>Files:</p>
<ul>
  <li>Filenames and directory names are PascalCase: <code>MyFile.cs</code></li>
  <li>Where possible the file name should be the same as the name of the main class in the file: <code>MyClass.cs</code></li>
  <li>In general, prefer one class or enum per file. This means enums and files should be seperated.</li>
  <li>Enums should be their own file where it makes sense.</li>
</ul>
<h6>Organization</h6>
<ul>
  <li>Modifiers occur in the following order: <code>public</code> <code>protected</code> <code>internal</code> <code>private</code> <code>new</code> <code>abstract</code> <code>viritual</code> <code>override</code> <code>sealed</code> <code>static</code> <code>readonly</code> <code>extern</code> <code>unsafe</code> <code>volatile</code> <code>async</code></li>
  <li>Namespace <code>using</code> declarations go at the top, <strong>BEFORE</strong> any namespaces. <code>using</code> import order is alphabetical, apart from <code>System</code> or <code>Microsoft</code> imports which <strong>always</strong> go first.</li>
  <li>Class member ordering:<ul>
      <li>Group class members in the following order:<ul>
          <li>Nested classes, enums, delegates and events</li>
          <li>Static, const and readonly fields.</li>
          <li>Fields and properties.</li>
          <li>Constructors and finalizers.</li>
          <li>Methods</li>
        </ul>
      </li>
      <li>Within each group, elements should be in the following order:<ul>
          <li>Public</li>
          <li>Internal</li>
          <li>Protected internal</li>
          <li>Protected</li>
          <li>Private</li>
        </ul>
      </li>
      <li>Where possible, group interface implementations together.</li>
    </ul>
  </li>
</ul>
<h6>Whitespace rules</h6>
<p>Developed from Google's Java style.</p>
<ul>
  <li>A maximum of ONE statement per line.</li>
  <li>A maximum of ONE assignement per statement.</li>
  <li>Indentation of 2 spaces, no tabs.</li>
  <li>Column limit: 100.</li>
  <li>Line break before opening brace, except for <code>if</code></li>
  <li>NO line break between closing brace and <code>else</code></li>
  <li>Single space before <code>else</code></li>
  <li>Braces used even when optional</li>
  <li>No space after an opening paranthesis and before a closing Paranethesis.</li>
  <li>No space between an unary operater and its operand. One space bween the operator and each operand of all other operators.</li>
  <li>Line warapping:<ul>
      <li>In general, line continuations are indented 4 spaces.</li>
      <li>Line breaks with braces (e.g. list inits, lamabads, object inits, etc) do NOT count as continuations.</li>
      <li>For function definitions and calls, if the argument do not all fit in one line they should be broken onto multiple lines,&nbsp;<br>with each subsequent line aligned with the first argument. If there is not enough room for this, arguments may instead be placed<br>on subsequent lines with a four space indent.</li>
    </ul>
  </li>
</ul>
<h5>Example:</h5>
<pre><code class="language-cs">//'using' goes at the top, outside of the namespace.
//Sort usings from: System, Microsoft and then Alphabetical

using System;
using Microsoft.Extensions.Primities;
using Newtonsoft.Json;

//Namespaces are PascalCase
namespace MyNamespace
//Indantation before the bracket
{
    //Interfaces start with an 'I'
    public interface IMyInterface
    {
        public int Calculate(float value, float exp);
    }

    //Enumerations are PascalCase
    public enum MyEnum
    {
        //Enumerators are PascalCase
        Yes,
        No,
    }

    //Classes are PascalCase.
    public class MyClass
    {
        //Backing fields are at the top.
        //Const does not affect naming conventions
        private const int _barSize = 100;

        //Backing Fields are _camelCase
        //Field initializers are encouraged.
        private bool _noCounting = false;

        //Container initializers use a 2 space indent.
        private int[] _someTable =
        {
            2, 3, 4
        }

        //Public member variables are PascalCase
        public int Foo = 0;

        //public properties with backing fields, should be used where needed
        public bool NoCounting
        {
            get =&gt; return _noCounting;
            set =&gt; SetValue(ref _noCounting, value);
        }

        //Indent before bracket during method call
        public MyClass()
        {
            //Object initializers use a 2 space indent.
            _results = new Results
            {
                NumNegativeResults = 1,
                NumPositiveResults = 1,
            }
        }

        public int CalculateValue(int mulNumber)
        {
            var resultValue = Foo * mulNumber;
            NumTimesCalled++;
            Foo += _bar;

            //No newline before opening brace
            if (!NoCounting)
            {
                //No space before 'if"
                //Braces used even when optional
                if (resultValue &lt; 0)
                {
                    _results.NumNegativeResults++;
                    //No newline between brace and else, space before else
                }
                else if (resultValue &gt; 0)
                {
                    _results.NumPositiveResults++
                }
            }

            return resultValue;
        }

        public void ExpressionBodies()
        {
            // For simple lambdas, fit on one line if possible, no brackets or braces required.
            Func&lt;int, int&gt; increment = x =&gt; x + 1;

            // Closing brace aligns with first character on line that includes the opening brace.
            Func&lt;int, int, long&gt; difference1 = (x, y) =&gt;
            {
                long diff = (long)x - y;
                return diff &gt;= 0 ? diff : -diff;
            };

            // If defining after a continuation line break, indent the whole body.
            Func&lt;int, int, long&gt; difference2 =
                (x, y) =&gt;
                {
                    long diff = (long)x - y;
                    return diff &gt;= 0 ? diff : -diff;
                };

            // Inline lambda arguments also follow these rules. Prefer a leading newline before
            // groups of arguments if they include lambdas.
            CallWithDelegate(
                (x, y) =&gt;
                {
                    long diff = (long)x - y;
                    return diff &gt;= 0 ? diff : -diff;
                });
        }

        //Empty blocks may be concise.
        void DoNothing()
        {
        }

        //If possible, wrap arguments by aligning newlines with the first argument.
        void AVeryLongFunctionNameThatCausesLineWrappingProblems(int longArgumentName,
            															int p1, int p2)
        {
        }

        // If aligning argument lines with the first argument doesn't fit, or is difficult to
        // read, wrap all arguments on new lines with a 4 space indent.
        void AnotherLongFunctionNameThatCausesLineWrappingProblems(
            int longArgumentName, int longArgumentName2, int longArgumentName3)
        {
        }

        void CallingLongFunctionName()
        {
            int veryLongArgumentName = 1234;
            int shortArg = 1;
            // If possible, wrap arguments by aligning newlines with the first argument.
            AnotherLongFunctionNameThatCausesLineWrappingProblems(shortArg, shortArg,
                														veryLongArgumentName);
            // If aligning argument lines with the first argument doesn't fit, or is difficult to
            // read, wrap all arguments on new lines with a 4 space indent.
            AnotherLongFunctionNameThatCausesLineWrappingProblems(
                veryLongArgumentName, veryLongArgumentName, veryLongArgumentName);
        }
    }
}</code></pre>
<p>&nbsp;</p>
