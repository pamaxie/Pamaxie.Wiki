<!--
title: C# Code Styleguide
description: Styleguide on how we want C# Code to be developed for Pamaxie
published: true
date: 2021-09-14T12:44:55.636Z
tags: 
editor: ckeditor
dateCreated: 2021-09-13T12:42:44.983Z
-->

<h1>C# with Pamaxie</h1>
<p>This tyle guide is for C# code that was developed by Pamaxies team and is used in all its publically facing or internal projects. It makes choices to make the style of coding uniform across applications and languages such as C or C++. This is build off of <a href="https://google.github.io/styleguide">Googles Code Style Guide</a>.</p>
<h1>Formatting Guidelines</h1>
<h6>Naming Rules</h6>
<p>Naming rules follow <a href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines">Microsoft's C# naming guidelines</a>. Where Microsoft's naming guidelines are unspecified (e. g. private and local variables), the rules can be seen below.</p>
<h6>Rules Summary:</h6>
<p><strong>Code:</strong></p>
<ul>
  <li>Names of classes, methods, enumerations, public fields, public properties, namespaces: <code>PascalCase</code></li>
  <li>Names of local variables, parameters: <code>camelCase</code></li>
  <li>Names of private, protected, internal and protected internal fields and properties: <code>_camelCase</code></li>
  <li>Naming convention is unaffected by modifiers such as const, static, readonly, overwrite, etc…</li>
  <li>For casing a “word” is anything written without internal spaces, including acronyms. This would mean <code>RPC</code> would become <code>Rpc</code></li>
  <li>Enums should be seperated out of classes whenever it isn't only required for that class.</li>
  <li>Names of interfaces start with an capital I: <code>IInterface</code></li>
  <li>Names of enums should be in singular.</li>
</ul>
<p>Files:</p>
<ul>
  <li>Filenames and directory names are PascalCase: <code>MyFile.cs</code></li>
  <li>Where possible the file name should be the same as the name of the main class in the file: <code>MyClass.cs</code></li>
  <li>In general, prefer one class or enum per file. This means enums and files should be seperated.</li>
  <li>Enums should be their own file where it makes sense.</li>
</ul>
<h6>Organization</h6>
<ul>
  <li>Modifiers occur in the following order: <code>public</code> <code>protected</code> <code>internal</code> <code>private</code> <code>new</code> <code>abstract</code> <code>viritual</code> <code>override</code> <code>sealed</code> <code>static</code> <code>readonly</code> <code>extern</code> <code>unsafe</code> <code>volatile</code> <code>async</code></li>
  <li>Namespace <code>using</code> declarations go at the top, <strong>BEFORE</strong> any namespaces. <code>using</code> import order is alphabetical, apart from <code>System</code> or <code>Microsoft</code> imports which <strong>always</strong> go first.</li>
  <li>Class member ordering:<ul>
      <li>Group class members in the following order:<ul>
          <li>Nested classes, enums, delegates and events</li>
          <li>Static, const and readonly fields.</li>
          <li>Fields and properties.</li>
          <li>Constructors and finalizers.</li>
          <li>Methods</li>
        </ul>
      </li>
      <li>Within each group, elements should be in the following order:<ul>
          <li>Public</li>
          <li>Internal</li>
          <li>Protected internal</li>
          <li>Protected</li>
          <li>Private</li>
        </ul>
      </li>
      <li>Where possible, group interface implementations together.</li>
    </ul>
  </li>
</ul>
<h6>Whitespace rules</h6>
<p>Inspired from Google's Java and C# style.</p>
<ul>
  <li>A maximum of ONE statement per line.</li>
  <li>A maximum of ONE assignement per statement.</li>
  <li>Indentation of one tab.</li>
  <li>Column limit: 100.</li>
  <li>Line break before opening brace</li>
  <li>Line break between functions and <code>static</code>, <code>public</code> and <code>private</code> properties.</li>
  <li>Two linebreaks between <code>public</code>, <code>private</code> and <code>static</code> methods</li>
  <li>Line break between closing brace and <code>else</code></li>
  <li>NewLines <strong>before </strong>and <strong>after</strong> <code>if</code> / <code>foreach</code> / <code>for</code> blocks</li>
  <li>Braces used even when optional</li>
  <li>Properties with backing fields should <strong>ONLY</strong> be used when needed.</li>
  <li>No space after an opening paranthesis and before a closing Paranethesis.</li>
  <li>No space between an unary operater and its operand. One space bween the operator and each operand of all other operators.</li>
  <li>Line warapping:<ul>
      <li>In general, line continuations are indented 4 spaces.</li>
      <li>Line breaks with braces (e.g. list inits, lamabads, object inits, etc) do NOT count as continuations.</li>
      <li>For function definitions and calls, if the argument do not all fit in one line they should be broken onto multiple lines,&nbsp;<br>with each subsequent line aligned with the first argument. If there is not enough room for this, arguments may instead be placed<br>on subsequent lines with a four space indent.</li>
    </ul>
  </li>
</ul>
<h5>Example:</h5>
<pre><code class="language-cs">using System; //'using' goes at the top, outside of the namespace.
using Microsoft.Extensions.Primities; //Sort usings from: System, Microsoft and then Alphabetical
using Newtonsoft.Json;


namespace MyNamespace //Namespaces are PascalCase
{ //Indantation before the bracket
    public interface IMyInterface //Interfaces start with an 'I'
    {
        public int Calculate(float value, float exp);
    }

    public enum MyEnum //Enumerations are PascalCase
    {
        Yes, //Enumerators are PascalCase
        No,
    }

    public class MyClass //Classes are PascalCase.
    {
        private const int _barSize = 100; //Backing fields are at the top. Const does not affect naming conventions
        private bool _noCounting = false; //Backing Fields are _camelCase. Field initializers are encouraged.
        private int[] _someTable = //Container initializers use a tab space indent.
        {
        	2, 3, 4
        }


        public int Foo = 0;//Public member variables are PascalCase, two newlines between private and public properties.

        public bool NoCounting //public properties with backing fields, should only be used where needed
        {
            get =&gt; return _noCounting;
            set =&gt; SetValue(ref _noCounting, value);
        }

        public MyClass() //Indent before bracket during method call, constructor comes after fields and properties.
        {
            _results = new Results //Object initializers use a tab space indent.
            {
                NumNegativeResults = 1,
                NumPositiveResults = 1,
            }
        }
        
        private void DoNothing(){} //Empty blocks may be concise.

        private void AVeryLongFunctionNameThatCausesLineWrappingProblems(int longArgumentName, //If possible, wrap arguments by aligning newlines with the first argument.
            																										 int p1, int p2)
        {
        }

        private void AnotherLongFunctionNameThatCausesLineWrappingProblems( // If aligning argument lines with the first argument doesn't fit, or is difficult to
            int longArgumentName, int longArgumentName2, int longArgumentName3)  // read, wrap all arguments on new lines with a 4 space indent
        {
        }

        private void CallingLongFunctionName()
        {
            int veryLongArgumentName = 1234;
            int shortArg = 1;
            
            AnotherLongFunctionNameThatCausesLineWrappingProblems(shortArg, shortArg, // If possible, wrap arguments by aligning newlines with the first argument.
                																									veryLongArgumentName);
            
            
            AnotherLongFunctionNameThatCausesLineWrappingProblems( // If aligning argument lines with the first argument doesn't fit, or is difficult to
                veryLongArgumentName, veryLongArgumentName, veryLongArgumentName); // read, wrap all arguments on new lines with a 4 space indent.
        }
        
        
        public int CalculateValue(int mulNumber) // two newlines between public and private methods.
        {
            var resultValue = Foo * mulNumber;
            NumTimesCalled++;
            Foo += _bar;

            if (!NoCounting) //Newline before if statemnt and opening brace
            {
            	
                if (resultValue &lt; 0) //Newline before if blocks
                { //Braces used even when optional
                    _results.NumNegativeResults++;
                    
                } //New between brace and else
                else if (resultValue &gt; 0)
                {
                    _results.NumPositiveResults++
                }
            }

            return resultValue; //Newline after if blocks
        }

        public void ExpressionBodies()
        {
            Func&lt;int, int&gt; increment = x =&gt; x + 1; //For simple lambdas, fit on one line if possible, no brackets or braces required.
            
            Func&lt;int, int, long&gt; difference1 = (x, y) =&gt; //Closing brace aligns with first character on line that includes the opening brace.
            {
                long diff = (long)x - y;
                return diff &gt;= 0 ? diff : -diff;
            };
            
            Func&lt;int, int, long&gt; difference2 = // If defining after a continuation line break, indent the whole body.
                (x, y) =&gt;
                {
                    long diff = (long)x - y;
                    return diff &gt;= 0 ? diff : -diff;
                };
                
            CallWithDelegate( // Inline lambda arguments also follow these rules. Prefer a leading newline before groups of arguments if they include lambdas.
                (x, y) =&gt;
                {
                    long diff = (long)x - y;
                    return diff &gt;= 0 ? diff : -diff;
                });
        }
    }
}</code></pre>
<h1>C# coding guidelines</h1>
<h6>Constants</h6>
<ul>
  <li>Variables and fields that can be made <code>const</code> should ALWAYS be made <code>const</code>.</li>
  <li>If <code>const</code> isn't possible, <code>readonly</code> static can be a suitable alternative.</li>
  <li>if <code>readonly</code> isn't possible, consider using a <code>static</code> value.</li>
</ul>
<h6>IEnumerable vs IList vs IReadOnlyList</h6>
<ul>
  <li>For inputs use the most restrictive collection type possible, for example <code>IReadOnlyCollection</code> / <code>IReadOnlyList</code> / <code>IEnumerable</code> as imputs to methods when the inputs should be made immutable.</li>
  <li>For outsputs, if passing ownership of the returned container to the owner, prefer <code>IEnumerable</code> over <code>IList</code>. If not transferning ownership, prefer the most restrictive option.</li>
</ul>
<h6>Generators vs containers</h6>
<p>Use your best judgement depending on scenario. Please keep in mind that while generator code is often less readable than filling in a container, it can be more performant, except if it is directly turned into a container via <code>.ToList()</code>. Also using generator code that is called multiple times will be considerably slower than iterating over a container multiple times.</p>
<h6>Propety Styles</h6>
<ul>
  <li>For single line, readonly properties, prefer expression body properties (=&gt;) when possible.</li>
  <li>For everything else use the older <code>{ get; set; }</code> syntax.</li>
</ul>
<h6>Expression body syntax</h6>
<p>For example:</p>
<pre><code class="language-cs">int SomeProperty =&gt; _someProperty;</code></pre>
<p>&nbsp;</p>
<ul>
  <li>Use expression syntax in lambadas and properties where possible.</li>
  <li>Use on method definitions.</li>
  <li>As with methods and other scoped blocks of code, align the closing with the first character of the line that includes the opening brace.<br>Se sample code for examples</li>
</ul>
<h6>Structs and classes</h6>
<ul>
  <li>Structs are different from classes:<ul>
      <li>Structs are ALWAYS passed and returned by value</li>
      <li>Assigning a value to a member of a returned struct doesn't modify the original - e.g. <code>transform.position.x = 10</code> doesn't set the transform's <code>position.x</code> to 10;&nbsp;<br><code>position</code> here is a property that returns a <code>Vector3</code> by value, so this just sets the x parameter of a copy of the original.</li>
    </ul>
  </li>
  <li>Almost alyways use a class when possible</li>
  <li>Consider struct when the type can be treated like any other value types. For example: if instances of the type are small and communly short lived or commonly embedded in other objects. (Good example are: Vector3, Bounds, Quaternion)</li>
  <li>Note that this guide may vary on this, for example, performance issues may force us to use structs.</li>
</ul>
<h6>Lambdas vs named methods</h6>
<ul>
  <li>If a lambda is non-trivial (e.g. more than a couple of statements, exclude declarations), or is reused in multiple places, it should probably be a named method.</li>
  <li>Avoid using Lambdas for complex sorting / searches, <code>for</code> / <code>foreach</code> loops should be applied where debugging the software gets too complex</li>
</ul>
<h6>Field initializers</h6>
<ul>
  <li>Field initializers are generally encouraged.</li>
</ul>
<h6>Extension methods</h6>
<ul>
  <li>Only use extension methods when the source of the original class is not available, or else when changing the source could would not be feasable.</li>
  <li>Only use an extension method if the functionality being added is a ‘core’ general feature that would be approperiate to add to the source of the original class.</li>
  <li>Only put extension methods into core libraries / classes that are available everywhere - extensions that are only available in some code (projects), which use things like <code>strings</code> will become a readability issue.</li>
  <li>Be aware that using extension methods ALWAYS obfuscates the code, so err on the side of not adding them.</li>
</ul>
<h6>ref amd pit</h6>
<ul>
  <li>Use <code>out</code> for returns that are not also inputs.</li>
  <li>Place <code>out</code> parameters after ALL other parameters in the method definition.</li>
  <li><code>ref</code> should only be used, when mutating an input is nessecary.</li>
  <li>Do not use <code>ref</code> as an optimization for passing structs.</li>
  <li>Do not use <code>ref</code> to pass a modifiable container into a method. <code>ref</code> is only required when the supplied container needs to be replaced with an entirely different container instance.</li>
</ul>
<h6>LINQ</h6>
<ul>
  <li>In general, prefer single line LINQ calls and imperative code, rather than long chains of LINQ. Mixing imperative code and heavily chained LINQ is often harder to read.</li>
  <li>Do not use SQL-Style LINQ keywords - e.g. use <code>myList.Where(x)</code> not <code>myList where x</code>.</li>
  <li>Avoid <code>Container.Foreach(…)</code> for anything that is longer than a single statement (prefer for loops).</li>
  <li>Wrap long LINQ statements with a new line after each statement. Indent the newline to start on the same height as other LINQ statements when possible.</li>
</ul>
<p>Example:</p>
<pre><code class="language-cs">
var types = myList.Where(x =&gt; x.Name == SearchedForName) 	//Wrap long LINQ statements with a new line after each statement.
	  			  .Select(x =&gt; x.Types).ToArray(); 			//Indent newline to start on the same height as other statements when possible.

for(int i = 0; i &gt; types.Lenth; i++) // avoid foreach for anything longer than single statement
{
	
	if(type == searchedForType) //newline before if statement
	{
		return;
	}
}</code></pre>
<h6>Array vs <code>List&lt;&gt;</code></h6>
<ul>
  <li>In general, prefer <code>List&lt;&gt;</code> over arrays for public variables, properties and return types (please keep in mind the guidance on using the right container types above).</li>
  <li>Prefer <code>List&lt;&gt;</code> everywhere the container size may change.</li>
  <li>Prefer arrays when the size of the container is fixed and known during construction time.</li>
  <li>Prefer array for multidimensional arrays</li>
  <li>Note:<ul>
      <li>arrays and <code>List&lt;&gt;</code> both represent linear, contiguous containers.</li>
      <li>Similar to C++ <code>arrays</code> vs <code>std::vector</code>, arrays are fixed capacity, whereas <code>List&lt;&gt;</code> can be added easily.</li>
      <li>In some cases arrays may be more performant, but a <code>List&lt;&gt;</code> is more flexible. Please consider this while making your choice which one to use</li>
    </ul>
  </li>
</ul>
<h6>Folders and file locations</h6>
<ul>
  <li>Stay consistent with the project.</li>
  <li>Prefer a flatter structure where possible. Avoid creating namespaces where possible.</li>
</ul>
<h6>Use of tuple as a return type</h6>
<ul>
  <li>In general, prefer using a named class over <code>Tuple&lt;&gt;</code>, particularly when returning complex types.</li>
</ul>
<h6>String interpolation vs <code>String.Format()</code> vs <code>String.Concat</code> vs operator +</h6>
<ul>
  <li>Use whatever is easiest to read, particularly for logging and assert messages.</li>
  <li>Be aware that chained operator+ concatenations will be slower and cause significant memory churn.</li>
  <li>If performance is a concern, StringBuilder will be fastest for multiple string concatenations.</li>
</ul>
<h6><code>Using</code></h6>
<ul>
  <li>Generally, don't alias long typenames with <code>using</code>. Often this is a singn that a <code>Tuple&lt;&gt;</code> needs to be turned into a class.<ul>
      <li>example: <code>using RecordList = List&lt;Tuple&lt;int, float&gt;&gt;</code></li>
    </ul>
  </li>
  <li>Be aware that <code>using</code> statements are only file scoped and thus of limited use. Type aliasses should not be available for external users.</li>
</ul>
<h6>Object Initialization Syntax</h6>
<pre><code class="language-cs">var x = new SomeClass
{
	Property1 = value1,
	Property2 = value2,
}</code></pre>
<p>&nbsp;</p>
<ul>
  <li>Object initializer Syntax is fine for ‘plain old data' types.</li>
  <li>Avoid using this syntax for classes or structs with constructors.</li>
  <li>if splitting across multiple lines, indent one block level.</li>
  <li>Prefer the above syntax over assigning properties manually (see below)</li>
</ul>
<pre><code class="language-cs">var x = new SomeClass();
x.Property1 = value1;
x.Proeprty2 = value2;</code></pre>
<h6>Namespace naming</h6>
<ul>
  <li>In general, namespaces should be no more than 3 levels deep. (Pamaxie.Database.Functions)</li>
  <li>Don't force file/folder layout to match namespaces.</li>
  <li>New top-level namespace names must be globally unique over all of Pamaxies Projects. (even different programming languages, for example Pamaxie.Database can only exist ONCE)</li>
</ul>
<h6>Default values / null returns for structs</h6>
<ul>
  <li>With structs, prefer returning a ‘success’ boolean with with an <code>out</code> value holding the struct.</li>
  <li>Where performance isn't a concern and the search result code becomes significantly more readable (e.g. chained null conditional operators vs deeply nested if satements) nullable structs are acceptable.</li>
  <li>We generally enforce a <strong>Null is a failure </strong>pattern at Pamaxie. This means if somethning returns a false for failure, make sure the out value is also null or the <code>default()</code> value of that datatype when null is not possible (to be avoided).</li>
</ul>
<h6>Removing from containers while iterating</h6>
<p>C# (like many other languages) does not provide and obvious mechanism for removing items from containers while itereating. There are a couple of operations:</p>
<ul>
  <li>If all that is required to remove items that satisfy some condition, <code>someList.RemoveAll(somePredicate)</code> is recommended.</li>
  <li>If other work needs to be done in the iteration, RemoveAll may not be sufficient. A common alternative pattern is to create a new container outside of the loop,&nbsp;<br>insert items to keep in the new container and swap the original container with the new one at the end of the interation. (see below for example)</li>
</ul>
<pre><code class="language-cs">var newContainer = originalContainer.ToArray();

for(int i = 0; i &gt; originalContainer.Lenth; i++)
{
	
	if (searchingForThis == originalContainer[i])
	{
		newContainer[i] = originalContainer[i];
	}
}

originalContainer = newContainer.ToList();</code></pre>
<h6>The <code>var</code> keyword</h6>
<ul>
  <li>The use of var is generally discouraged, it often disturbs readability.</li>
  <li>Encouraged:<ul>
      <li>When the type is obvious - e.g. <code>var apple = new Apple()</code>, or <code>var request = Factory.Create&lt;HttpRequest&gt;();</code>&nbsp;</li>
    </ul>
  </li>
  <li>Discouraged:<ul>
      <li>When working with basic types - e.g. <code>var success = true;</code></li>
      <li>when working with compiler-resolved built-in numeric types - e.g. <code>var number = 12 * ReturnsAFloat();</code></li>
      <li>When users would clearly benefit from knowing the type - e.g. <code>var listOfItems = GetList();</code></li>
      <li>For transient variables that are only passed directly to other methods. - e.g. <code>var item = GetItem(); ProcessItem(item);</code></li>
    </ul>
  </li>
</ul>
<h6>Attributes</h6>
<ul>
  <li>Attributes should appear on the line above the field, property or method thay are associated with, seperated from the member by a newline.</li>
  <li>Multiple attributed should be seperated by newlines. This allowes for easing adding and removing of attributes and ensures each attribute is easy to search for.</li>
</ul>
<h6>Argument Naming</h6>
<p>Derivated from the Google C++ and C# style guide.<br>When the meaning of a function argument is nonobvious consider one of the following remidies:</p>
<ul>
  <li>If the argument is a literal constant, and the same constant is used in multiple function calls in a way that tacticaly assumes the'yre the same, use a named constant to make that constraint explicit and to guarantee that it holds.</li>
  <li>Consider changing the function signature to replace a bool with an enum argument. This may make the argument values self-describing.</li>
  <li>Replace large or complex nested expressions with named variables.</li>
  <li>Consider using Named Arguments to clarify argument meanings at the call site.</li>
  <li>For functions that have several configuration options, consider defining a single class or struct to hold all the options and pass an instance of that.&nbsp;<br>This approach has several advantages. Options are referenced by name at the call site, which clarifies their meaning.&nbsp;<br>It also reduces function argument count, which makes function calls easier to read and write.&nbsp;<br>As an added benefit, call sites don’t need to be changed when another option is added.</li>
</ul>
<p>Consider the following example:</p>
<pre><code class="language-cs">// Bad - what are these arguments?
DecimalNumber product = CalculateProduct(values, 7, false, null);</code></pre>
<p>versus:</p>
<pre><code class="language-cs">// Good
ProductOptions options = new ProductOptions();
options.PrecisionDecimals = 7;
options.UseCache = CacheUsage.DontUseCache;
DecimalNumber product = CalculateProduct(values, options, completionDelegate: null);</code></pre>
<h6>Comparison operators</h6>
<ul>
  <li>Prefer symbols over written out comparison operators - e.g. use <code>||</code> over <code>or</code></li>
  <li>For comparison consider adding a new line after comparison blocks (see example below)</li>
</ul>
<pre><code class="language-cs">if (value 1 != value 2 &amp;&amp;
	value 2 != value 3 &amp;&amp;
	value 3 != value 1)
{
	//DoSomething
}</code></pre>
